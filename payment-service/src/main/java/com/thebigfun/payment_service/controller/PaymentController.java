package com.thebigfun.payment_service.controller;import com.thebigfun.payment_service.dtos.PaymentRequest;import com.thebigfun.payment_service.model.Payment;import com.thebigfun.payment_service.service.BlockchainService;import com.thebigfun.payment_service.service.Impl.PaymentServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import java.time.LocalDateTime;import java.time.temporal.ChronoUnit;import java.util.List;import java.util.Map;@RestController@RequestMapping("/api/payments_services")public class PaymentController {    private final PaymentServiceImpl paymentServiceImpl;    private final BlockchainService blockchainService;    @Autowired    public PaymentController(PaymentServiceImpl paymentServiceImpl, BlockchainService blockchainService){        this.paymentServiceImpl = paymentServiceImpl;        this.blockchainService = blockchainService;    }    @PostMapping    public ResponseEntity<Payment> createPayment(@RequestBody Payment payment){        Payment createdPayment = paymentServiceImpl.createPayment( payment);        return new ResponseEntity<>(createdPayment, HttpStatus.CREATED);    }    @GetMapping    public ResponseEntity<List<Payment>>getAllPayments(){        List<Payment> paymentList = paymentServiceImpl.getAllPayments();        return new ResponseEntity<>(paymentList, HttpStatus.OK);    }    @GetMapping("/{id}")    public ResponseEntity<Payment> getEventById(@PathVariable Long id) {        try {            Payment payment = paymentServiceImpl.getPaymentById(id);            return ResponseEntity.ok(payment);        } catch (RuntimeException ex){            return ResponseEntity.notFound().build();        }    }    @PutMapping("/{id}")    public ResponseEntity<Payment> updatePayment(@PathVariable Long id, @RequestBody Payment payment) {        try {            Payment updatedpayment = paymentServiceImpl.updatePayment(id, payment);            return new ResponseEntity<>(updatedpayment, HttpStatus.OK);        } catch (RuntimeException e) {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    // Eliminar un ticket    @DeleteMapping("/{id}")    public ResponseEntity<Void> deletePayment(@PathVariable Long id) {        paymentServiceImpl.deletePayment(id);        return  ResponseEntity.ok().build();    }    @GetMapping("/exists/{paymentId}")    public ResponseEntity<Boolean> existsPaymentByPaymentId(@PathVariable Long paymentId) {        boolean exists = paymentServiceImpl.existsPaymentByPaymentId(paymentId);        return ResponseEntity.ok(exists);    }    // Endpoint para procesar pagos con Stripe    @PostMapping("/stripe")    public ResponseEntity<Payment> processStripePayment(@RequestBody PaymentRequest request) {        Payment payment = paymentServiceImpl.processStripePayment(request);        return ResponseEntity.ok(payment);    }    // Endpoint para procesar pagos con Culqi    @PostMapping("/culqi")    public ResponseEntity<Payment> processCulqiPayment(@RequestBody PaymentRequest request) {        Payment payment = paymentServiceImpl.processCulqiPayment(request);        return ResponseEntity.ok(payment);    }   //http://localhost:8082/api/payments_services/blockchain/register    @PostMapping("/blockchain/register")    public ResponseEntity<String> registerPayment(@RequestBody Payment payment) {        try {            // Extrae los campos necesarios para la blockchain            String paymentId = payment.getPaymentId();            Double amount = payment.getAmount();            String currency = payment.getCurrency();            Long userId = payment.getUserId();            // Registra el pago en la blockchain y obtiene el hash de la transacción            String transactionHash = blockchainService.registerPayment(paymentId, amount.longValue(), currency,userId);            if (transactionHash == null) {                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error al registrar el pago en la blockchain.");            }            LocalDateTime now = LocalDateTime.now();            LocalDateTime timestamp = now.truncatedTo(ChronoUnit.SECONDS);            payment.setTransactionHash(transactionHash);            payment.setTimestamp(timestamp);            paymentServiceImpl.createPayment(payment);            return ResponseEntity.ok("Pago registrado en la blockchain y guardado en la base de datos exitosamente.");        } catch (Exception e) {            e.printStackTrace();            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error al registrar el pago en la blockchain.");        }    }    //http://localhost:8082/api/payments_services/blockchain/register/generateTransferCode    @PostMapping("/blockchain/generateTransferCode")    public ResponseEntity<String> generateTransferCode(@RequestParam String paymentId) {        try {            String transferCode = blockchainService.generateTransferCode(paymentId);            if (transferCode == null) {                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error al generar el código de transferencia.");            }            // Actualizar la base de datos con el código de transferencia            Payment payment = paymentServiceImpl.getPaymentByPaymentId(paymentId);            payment.setTransferCode(transferCode);            paymentServiceImpl.updatePayment(payment.getId(), payment);            return ResponseEntity.ok("Código de transferencia generado y guardado exitosamente.");        } catch (Exception e) {            e.printStackTrace();            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error al generar el código de transferencia.");        }    }//http://localhost:8082/api/payments_services/blockchain/redeemTransferCode    @PostMapping("/blockchain/redeemTransferCode")    public ResponseEntity<String> redeemTransferCode(            @RequestParam String paymentId,            @RequestParam String transferCode,            @RequestParam Long userId) {        try {            String newTransactionHash = blockchainService.redeemTransferCode(paymentId, transferCode, userId);            if (newTransactionHash == null) {                return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("No se pudo redimir el código de transferencia.");            }            paymentServiceImpl.updatePaymentDetails(paymentId, userId, newTransactionHash, LocalDateTime.now());            return ResponseEntity.ok("Código de transferencia redimido exitosamente: " + newTransactionHash);        } catch (Exception e) {            e.printStackTrace();            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Error al redimir el código de transferencia: " + e.getMessage());        }    }    //http://localhost:8080/api/payments_services/blockchain/paymentDetails?paymentId=payment100    @GetMapping("/blockchain/paymentDetails")    public ResponseEntity<Map<String, String>> getPaymentDetailsWithOwners(@RequestParam String paymentId) {        try {            Map<String, String> paymentDetails = blockchainService.getPaymentDetailsWithOwners(paymentId);            return ResponseEntity.ok(paymentDetails);        } catch (Exception e) {            return ResponseEntity.status(500).body(null);        }    }}