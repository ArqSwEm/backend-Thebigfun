package com.thebigfun.payment_service.service.Impl;import com.thebigfun.payment_service.dtos.PaymentRequest;import com.thebigfun.payment_service.model.Payment;import com.thebigfun.payment_service.repository.PaymentRepository;import com.thebigfun.payment_service.service.BlockchainService;import com.thebigfun.payment_service.service.PaymentGatewayService;import com.thebigfun.payment_service.service.PaymentService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.stereotype.Service;import java.time.LocalDateTime;import java.util.List;import java.util.Map;import java.util.Optional;@Servicepublic class PaymentServiceImpl implements PaymentService {    private final PaymentRepository paymentRepository;    private final PaymentGatewayService stripeService;    private final PaymentGatewayService culqiService;    private final BlockchainService blockchainService;    @Autowired    public PaymentServiceImpl(PaymentRepository paymentRepository, @Qualifier("stripeService") PaymentGatewayService stripeService,   @Qualifier("culqiService") PaymentGatewayService culqiService, BlockchainService blockchainService) {        this.paymentRepository = paymentRepository;        this.stripeService = stripeService;        this.culqiService = culqiService;        this.blockchainService = blockchainService;    }    @Override    public Payment createPayment(Payment payment) {        return paymentRepository.save(payment);    }    @Override    public List<Payment> getAllPayments() {        return paymentRepository.findAll();    }    @Override    public Payment getPaymentById(Long payment_id) {        return paymentRepository.findById(payment_id)                .orElseThrow(()->new RuntimeException("Payment not found"));    }    /*    @Override    public Payment updatePayment(Long payment_id, Payment payment) {        Payment existingPayment = paymentRepository.findById(payment_id)                .orElseThrow(()->new RuntimeException("Payment not found"));        existingPayment.setAmount(payment.getAmount());        existingPayment.setCurrency(payment.getCurrency());        existingPayment.setStatus(payment.getStatus());        return paymentRepository.save(existingPayment);    }     */    @Override    public Payment updatePayment(Long payment_id, Payment payment) {        Payment existingPayment = paymentRepository.findById(payment_id)                .orElseThrow(() -> new RuntimeException("Payment not found"));        existingPayment.setAmount(payment.getAmount());        existingPayment.setCurrency(payment.getCurrency());        existingPayment.setStatus(payment.getStatus());        existingPayment.setPaymentMethod(payment.getPaymentMethod());        existingPayment.setPaymentProvider(payment.getPaymentProvider());        existingPayment.setPaymentStatus(payment.getPaymentStatus());        existingPayment.setReceiptUrl(payment.getReceiptUrl());        existingPayment.setFailureMessage(payment.getFailureMessage());        return paymentRepository.save(existingPayment);    }    @Override    public void deletePayment(Long payment_id) {        Payment  payment = paymentRepository.findById(payment_id)                .orElseThrow(() -> new RuntimeException("Payment not found with id " + payment_id));        payment.setIsActive(false);        payment.setDeletedAt(LocalDateTime.now());        paymentRepository.save(payment);    }    @Override    public boolean existsPaymentByPaymentId(Long payment_id) {        return paymentRepository.existsById(payment_id);    }    @Override    public Payment processStripePayment(PaymentRequest request) {        return processPayment(request, stripeService, "Stripe");    }    @Override    public Payment processCulqiPayment(PaymentRequest request) {        return processPayment(request, culqiService, "Culqi");    }    private Payment processPayment(PaymentRequest request, PaymentGatewayService paymentGatewayService, String providerName) {        try {            // Procesar pago con la pasarela de pago            Map<String, Object> charge = paymentGatewayService.processPayment(request).block();            Payment payment = new Payment();            payment.setAmount(request.getAmount());            payment.setCurrency(request.getCurrency());            payment.setStatus(Payment.PaymentStatus.COMPLETED);            payment.setUserId(request.getUserId());            payment.setBookingId(request.getBookingId());            payment.setTransactionHash((String) charge.get("id"));            payment.setPaymentMethod("Credit Card"); // Esto debe ser determinado dinÃ¡micamente            payment.setPaymentProvider(providerName);            payment.setPaymentStatus((String) charge.get("status"));            payment.setReceiptUrl((String) charge.get("receipt_url"));            // Guardar en la base de datos            payment = paymentRepository.save(payment);            // Registrar en la blockchain            blockchainService.registerPayment(payment.getPaymentId(), (long) (payment.getAmount() * 100), payment.getCurrency(), payment.getUserId());            return payment;        } catch (Exception e) {            throw new RuntimeException(providerName + " payment failed", e);        }    }    @Override    public Payment getPaymentByPaymentId(String paymentId) {        return paymentRepository.findByPaymentId(paymentId).orElseThrow(() -> new RuntimeException("Payment not found"));    }    public void updatePaymentDetails(String paymentId, Long newOwnerId, String newTransactionHash, LocalDateTime transactionTimestamp) {        Optional<Payment> optionalPayment = paymentRepository.findByPaymentId(paymentId);        if (optionalPayment.isPresent()) {            Payment payment = optionalPayment.get();            payment.setNewTransactionHash(newTransactionHash);            payment.setTransactionTimestamp(transactionTimestamp);            payment.setNewOwnerId(newOwnerId);            paymentRepository.save(payment);        } else {            throw new RuntimeException("Payment not found with ID: " + paymentId);        }    }}