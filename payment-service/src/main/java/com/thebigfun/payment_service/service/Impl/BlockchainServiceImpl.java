package com.thebigfun.payment_service.service.Impl;import com.thebigfun.payment_service.model.Payment;import com.thebigfun.payment_service.repository.PaymentRepository;import com.thebigfun.payment_service.service.BlockchainService;import com.thebigfun.payment_service.service.Impl.contract.PaymentRegistry;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.core.io.ClassPathResource;import org.springframework.stereotype.Service;import org.springframework.web.reactive.function.client.WebClient;import org.web3j.abi.datatypes.Type;import org.web3j.crypto.Credentials;import org.web3j.protocol.Web3j;import org.web3j.protocol.core.RemoteCall;import org.web3j.protocol.core.methods.response.TransactionReceipt;import org.web3j.tx.gas.ContractGasProvider;import org.web3j.tx.gas.StaticGasProvider;import java.io.IOException;import java.math.BigInteger;import java.nio.charset.StandardCharsets;import java.nio.file.Files;import java.nio.file.Paths;import java.time.LocalDateTime;import java.time.format.DateTimeFormatter;import java.time.temporal.ChronoUnit;import java.util.HashMap;import java.util.List;import java.util.Map;import java.util.Optional;@Servicepublic class BlockchainServiceImpl implements BlockchainService {    private final Web3j web3j;    private final PaymentRegistry contract;    private final WebClient.Builder webClientBuilder;    private final PaymentRepository paymentRepository;    @Value("${api.gateway.base.url}")    private String apiGatewayBaseUrl;    @Autowired    public BlockchainServiceImpl(Web3j web3j,                                 @Value("${blockchain.contract.address}") String contractAddress,                                 @Value("${blockchain.contract.gas-price}") Long gasPrice,                                 @Value("${blockchain.contract.gas-limit}") Long gasLimit,                                 @Value("${blockchain.private-key}") String privateKey,                                 WebClient.Builder webClientBuilder,                                 PaymentRepository paymentRepository) throws IOException {        this.web3j = web3j;        this.webClientBuilder = webClientBuilder;        this.paymentRepository = paymentRepository;        if (privateKey == null || privateKey.isEmpty()) {            throw new IllegalStateException("PRIVATE_KEY property is not set.");        }        Credentials credentials = Credentials.create(privateKey);        ContractGasProvider gasProvider = new StaticGasProvider(BigInteger.valueOf(gasPrice), BigInteger.valueOf(gasLimit));        // Load ABI from JSON file        String contractAbi = new String(Files.readAllBytes(Paths.get(new ClassPathResource("contracts/PaymentRegistry.json").getURI())), StandardCharsets.UTF_8);        this.contract = PaymentRegistry.load(contractAddress, web3j, credentials, gasProvider, contractAbi);    }    @Override    public String registerPayment(String paymentId, Long amount, String currency, Long userId) {        try {            BigInteger bigAmount = BigInteger.valueOf(amount);            TransactionReceipt transactionReceipt = contract.registerPayment(paymentId, bigAmount, currency).send();            String transactionHash = transactionReceipt.getTransactionHash();            LocalDateTime now = LocalDateTime.now();            LocalDateTime timestamp = now.truncatedTo(ChronoUnit.SECONDS);            // Log details for verification            System.out.println("Pago registrado en blockchain:");            System.out.println("ID de Pago: " + paymentId);            System.out.println("Cantidad: " + amount);            System.out.println("Moneda: " + currency);            System.out.println("Owner: " + userId);            System.out.println("Transaction Hash: " + transactionHash);            System.out.println("Timestamp: " + timestamp.format(DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss")));            return transactionHash;        } catch (Exception e) {            System.err.println("Error al registrar el pago en la blockchain: " + e.getMessage());            return null;        }    }    @Override    public String generateTransferCode(String paymentId) {        try {            TransactionReceipt transactionReceipt = contract.generateTransferCode(paymentId).send();            String transferCode = PaymentRegistry.extractTransferCode(transactionReceipt);            System.out.println("Código de transferencia generado exitosamente para el pago con ID: " + paymentId);            return transferCode;        } catch (Exception e) {            System.err.println("Error al generar el código de transferencia: " + e.getMessage());            return null;        }    }    @Override    public String redeemTransferCode(String paymentId, String transferCode, Long userId) throws Exception {        String userServiceUrl = "http://localhost:8081/api/thebigfun/v1/users/" + userId + "/ethereum-address";        // Obtener la dirección Ethereum del usuario desde el microservicio de usuarios        String ethereumAddress = webClientBuilder.build()                .get()                .uri(userServiceUrl)                .retrieve()                .bodyToMono(String.class)                .block();        if (ethereumAddress == null || !ethereumAddress.matches("^0x[a-fA-F0-9]{40}$")) {            throw new IllegalArgumentException("Dirección Ethereum no válida.");        }        // Envío de la transacción con la dirección Ethereum válida        TransactionReceipt transactionReceipt = contract.redeemTransferCode(paymentId, transferCode, ethereumAddress).send();        // Asumiendo que la transacción fue exitosa, extraer el nuevo hash de transacción        String newTransactionHash = transactionReceipt.getTransactionHash();        // Validaciones adicionales y manejo de errores        if (newTransactionHash == null || newTransactionHash.isEmpty()) {            throw new Exception("No se pudo obtener el hash de la transacción.");        }        // Actualizar la información del pago en la base de datos        Optional<Payment> optionalPayment = paymentRepository.findByPaymentId(paymentId);        if (optionalPayment.isEmpty()) {            throw new Exception("Pago no encontrado");        }        Payment payment = optionalPayment.get();        payment.setNewTransactionHash(newTransactionHash);        payment.setTransactionTimestamp(LocalDateTime.now());        payment.setNewOwnerId(userId.longValue());        paymentRepository.save(payment);        return newTransactionHash;    }    @Override    public RemoteCall<List<Type>> getPayment(String paymentId) {        return contract.getPayment(paymentId);    }    @Override    public RemoteCall<String> getTransactionHash(String paymentId) {        return contract.getTransactionHash(paymentId);    }    @Override    public RemoteCall<List<Type>> getAllPayments() {        return contract.getAllPayments();    }    @Override    public Map<String, String> getPaymentDetailsWithOwners(String paymentId) {        try {            // Obtener los detalles del pago desde la base de datos            Optional<Payment> paymentOptional = paymentRepository.findByPaymentId(paymentId);            if (!paymentOptional.isPresent()) {                throw new RuntimeException("Pago no encontrado en la base de datos.");            }            Payment payment = paymentOptional.get();            Map<String, String> details = new HashMap<>();            details.put("paymentId", payment.getPaymentId());            details.put("amount", payment.getAmount().toString());            details.put("currency", payment.getCurrency());            details.put("timestamp", payment.getTimestamp().toString());            details.put("previousOwner", payment.getUserId().toString());            details.put("transactionHash", payment.getTransactionHash());            details.put("currentOwner", payment.getNewOwnerId() != null ? payment.getNewOwnerId().toString() : null);            details.put("newTransactionHash", payment.getNewTransactionHash());            return details;        } catch (Exception e) {            e.printStackTrace();            throw new RuntimeException("Error al obtener los detalles del pago: " + e.getMessage());        }    }}