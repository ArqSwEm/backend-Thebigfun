package com.thebigfun.booking_service.controller;import com.thebigfun.booking_service.dto.BookingDTO;import com.thebigfun.booking_service.model.Booking;import com.thebigfun.booking_service.service.impl.BookingServiceImpl;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.ResponseEntity;import org.springframework.web.bind.annotation.*;import reactor.core.publisher.Mono;import java.util.List;@RestController@RequestMapping("/api/bookings_services")public class Booking_ServiceController {    private final BookingServiceImpl bookingService;    @Autowired    public Booking_ServiceController(BookingServiceImpl bookingService1){        this.bookingService=bookingService1;    }    // Crear un nuevo Booking    @PostMapping    public ResponseEntity<Booking> createBooking(@RequestBody Booking booking){        Booking createdBooking = bookingService.createBooking(booking);        return  new ResponseEntity<>(createdBooking, HttpStatus.CREATED);    }    // Obtener todos los Reservas    @GetMapping    public ResponseEntity<List<Booking>>getAllBookings(){        List<Booking> listBooking = bookingService.getAllBookings();        return new ResponseEntity<>(listBooking, HttpStatus.OK);    }    // Obtener una reserva  específico por ID    @GetMapping("/{id}")    public ResponseEntity<Booking> getEventById(@PathVariable  Long id) {        try {            Booking booking = bookingService.getBookingById(id);            return ResponseEntity.ok(booking);        } catch (RuntimeException ex) {            return ResponseEntity.notFound().build();        }    }    // Actualizar un Reservas existente    @PutMapping("/{id}")    public ResponseEntity<Booking> updateBooking(@PathVariable Long id, @RequestBody Booking booking) {        try {            Booking updatedBooking = bookingService.updateBooking(id ,booking);            return new ResponseEntity<>(updatedBooking, HttpStatus.OK);        } catch (RuntimeException e) {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    // Eliminar un evento    @DeleteMapping("/{id}")    public ResponseEntity<Void> deleteBooking(@PathVariable Long id) {        try {            bookingService.deleteBooking(id);            return ResponseEntity.noContent().build();        } catch (RuntimeException e) {            return new ResponseEntity<>(HttpStatus.NOT_FOUND);        }    }    // Nuevo método para actualizar el estado del pago    @PatchMapping("/{id}/payment-status")    public ResponseEntity<Void> updatePaymentStatus(@PathVariable Long id, @RequestParam("status") Booking.PaymentStatus status) {        try {            bookingService.updatePaymentStatus(id, status);            return ResponseEntity.ok().build();        } catch (RuntimeException ex) {            return ResponseEntity.notFound().build();        }    }    // Método opcional para forzar la verificación de reservas expiradas    @GetMapping("/check-expired")    public ResponseEntity<Void> checkAndReleaseExpiredBookings() {        bookingService.checkAndReleaseExpiredBookings();        return ResponseEntity.ok().build();    }    // Obtener todas las reservas por ID de usuario    @GetMapping("/bookings/byUser/{userId}")    public ResponseEntity<List<BookingDTO>> getBookingsByUserId(@PathVariable Long userId) {        List<BookingDTO> bookings = bookingService.getBookingsByUserId(userId);        if (bookings.isEmpty()) {            return new ResponseEntity<>(HttpStatus.NO_CONTENT);        }        return new ResponseEntity<>(bookings, HttpStatus.OK);    }    //http://localhost:8080/api/bookings_services/updateTotalPrice/{userId}    @PostMapping("/updateTotalPrice/{userId}")    public ResponseEntity<String> updateBookingTotalPrice(@PathVariable Long userId) {        try {            bookingService.updateBookingTotalPrice(userId);            return ResponseEntity.ok("Total price updated successfully for user with ID: " + userId);        } catch (Exception e) {            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body("Failed to update total price: " + e.getMessage());        }    }}