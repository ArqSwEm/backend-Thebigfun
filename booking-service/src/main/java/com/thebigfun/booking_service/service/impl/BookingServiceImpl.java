package com.thebigfun.booking_service.service.impl;import com.thebigfun.booking_service.dto.BookingDTO;import com.thebigfun.booking_service.dto.TicketDTO;import com.thebigfun.booking_service.model.Booking;import com.thebigfun.booking_service.model.BookingMapper;import com.thebigfun.booking_service.repository.Booking_ServiceRepository;import com.thebigfun.booking_service.service.Booking_Service;import org.slf4j.Logger;import org.slf4j.LoggerFactory;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.scheduling.annotation.Scheduled;import org.springframework.stereotype.Service;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.reactive.function.client.WebClient;import reactor.core.publisher.Mono;import reactor.core.scheduler.Schedulers;import java.time.LocalDateTime;import java.util.List;@Servicepublic class BookingServiceImpl implements Booking_Service {    private static final Logger log = LoggerFactory.getLogger(BookingServiceImpl.class);    private final Booking_ServiceRepository booking_serviceRepository;    private final BookingMapper bookingMapper;    private final WebClient.Builder webClientBuilder;    private final WebClient webClient;    @Value("${api.gateway.base.url}")    private String apiGatewayBaseUrl;    @Autowired    public BookingServiceImpl(Booking_ServiceRepository bookingServiceRepository,                              BookingMapper bookingMapper,                              WebClient.Builder webClientBuilder,                              @Value("${api.gateway.base.url}") String apiGatewayBaseUrl ){        this.booking_serviceRepository = bookingServiceRepository;        this.bookingMapper=bookingMapper;        this.webClientBuilder = webClientBuilder;        this.webClient = webClientBuilder.baseUrl(apiGatewayBaseUrl).build();    }    @Override    @Transactional    public Booking createBooking(Booking booking) {        // Configura la fecha de expiración (ejemplo: 24 horas después de la creación)        //booking.setExpirationDate(LocalDateTime.now().plusHours(24));        booking.setReservationDate(LocalDateTime.now());        booking.setExpirationDate(LocalDateTime.now().plusMinutes(1));        booking.setPaymentStatus(Booking.PaymentStatus.AWAITING_PAYMENT);        booking.setStatus(Booking.BookingStatus.PENDING);        return booking_serviceRepository.save(booking);    }    /*    public Mono<Booking> createBookingWithCalculatedPrice(Long userId, Booking bookingDetails) {        return calculateTotalPriceForUser(userId)                .map(totalPrice -> {                    // Establece el total de precio calculado y otros detalles necesarios antes de guardar                    bookingDetails.setTotalPrice(totalPrice);                    bookingDetails.setReservationDate(LocalDateTime.now());                    bookingDetails.setExpirationDate(LocalDateTime.now().plusHours(24));                    bookingDetails.setPaymentStatus(Booking.PaymentStatus.AWAITING_PAYMENT);                    bookingDetails.setStatus(Booking.BookingStatus.PENDING);                    // Guarda la reserva en la base de datos de forma bloqueante                    return booking_serviceRepository.save(bookingDetails);                });    }    public void handleBookingCreation(Long userId, Booking bookingDetails) {        createBookingWithCalculatedPrice(userId, bookingDetails).subscribe(                booking -> System.out.println("Reserva creada con éxito: " + booking),                error -> System.err.println("Error al crear la reserva: " + error)        );    }*/    @Override    @Transactional    public List<Booking> getAllBookings() {        return booking_serviceRepository.findAll();    }    @Override    @Transactional(readOnly = true)    public Booking getBookingById(Long booking_id) {        return booking_serviceRepository.findById(booking_id).orElseThrow(()->new RuntimeException("Booking not found"));    }    @Override    @Transactional    public Booking updateBooking(Long booking_id, Booking bookingDetails) {        Booking existingBooking= booking_serviceRepository.findById(booking_id)                .orElseThrow(()-> new RuntimeException("Booking not found"));        existingBooking.setNumberOfTickets(bookingDetails.getNumberOfTickets());        existingBooking.setTotalPrice(bookingDetails.getTotalPrice());        existingBooking.setReservationDate(bookingDetails.getReservationDate());        existingBooking.setNotes(bookingDetails.getNotes());        existingBooking.setStatus(bookingDetails.getStatus());        existingBooking.setPaymentStatus(bookingDetails.getPaymentStatus());        return booking_serviceRepository.save(existingBooking);    }    @Override    @Transactional    public void deleteBooking(Long bookingId) {        Booking booking = booking_serviceRepository.findById(bookingId)                .orElseThrow(() -> new RuntimeException("Booking not found"));        // Comprobar si la reserva ya está cancelada o expirada para evitar trabajo innecesario        if (booking.getStatus() == Booking.BookingStatus.CANCELLED || booking.getStatus() == Booking.BookingStatus.EXPIRED) {            throw new IllegalStateException("Booking is already cancelled or expired.");        }        booking.setStatus(Booking.BookingStatus.CANCELLED);        booking_serviceRepository.save(booking);        // Opcional: Añadir lógica para reembolsos si el sistema lo requiere    }    @Override    @Transactional    public boolean existsBookingByBookingId(Long booking_id) {        return booking_serviceRepository.existsById(booking_id);    }   // actualiza los datos de acuerdo a la expiracion    @Override    @Transactional    public void updatePaymentStatus(Long bookingId, Booking.PaymentStatus paymentStatus) {        Booking booking = booking_serviceRepository.findById(bookingId)                .orElseThrow(() -> new RuntimeException("Booking not found"));        booking.setPaymentStatus(paymentStatus);        if (paymentStatus == Booking.PaymentStatus.PAID) {            booking.setStatus(Booking.BookingStatus.CONFIRMED);        } else if (paymentStatus == Booking.PaymentStatus.REFUNDED) {            booking.setStatus(Booking.BookingStatus.CANCELLED);        } else if (paymentStatus == Booking.PaymentStatus.AWAITING_PAYMENT) {            if (LocalDateTime.now().isBefore(booking.getExpirationDate())) {                booking.setStatus(Booking.BookingStatus.PENDING);            } else {                if (booking.getPaymentStatus() != Booking.PaymentStatus.PAID) { // Verificar que no esté pagado antes de establecer como EXPIRED                booking.setStatus(Booking.BookingStatus.EXPIRED);                booking.setPaymentStatus(Booking.PaymentStatus.REFUNDED);  // Suponiendo que la cancelación implica reembolso            }            }        }        booking_serviceRepository.save(booking);    }    //controla la expiracion        @Scheduled(fixedRate = 60000)        @Transactional        public void checkAndReleaseExpiredBookings() {            List<Booking> expiredBookings = booking_serviceRepository.findAllByStatusAndExpirationDateBefore(                    Booking.BookingStatus.PENDING, LocalDateTime.now());            for (Booking booking : expiredBookings) {                // Solo actualiza como expirado si el pago todavía está pendiente.                if (booking.getPaymentStatus().equals(Booking.PaymentStatus.AWAITING_PAYMENT)) {                    booking.setStatus(Booking.BookingStatus.EXPIRED);                    // Puedes optar por no actualizar el estado de pago a reembolsado,                    // o manejarlo de acuerdo a la lógica de tu negocio.                    // booking.setPaymentStatus(Booking.PaymentStatus.REFUNDED);                } else if (booking.getPaymentStatus().equals(Booking.PaymentStatus.PAID)) {                    // Si la reserva ya está pagada, se confirma la reserva.                    booking.setStatus(Booking.BookingStatus.CONFIRMED);                }                booking_serviceRepository.save(booking);            }        }    @Transactional    public void cancelBooking(Long bookingId) {        Booking booking = booking_serviceRepository.findById(bookingId)                .orElseThrow(() -> new RuntimeException("Booking not found"));        // Verificar si la reserva ya está cancelada o expirada para evitar trabajo innecesario.        if (booking.getStatus() == Booking.BookingStatus.CANCELLED || booking.getStatus() == Booking.BookingStatus.EXPIRED) {            log.info("Intento de cancelar una reserva que ya está cancelada o expirada. ID: {}", bookingId);            throw new IllegalStateException("Booking is already cancelled or expired.");        }        booking.setStatus(Booking.BookingStatus.CANCELLED);        // Actualizar el estado del pago a reembolsado solo si aún está pendiente o no ha sido pagado.        if (booking.getPaymentStatus() == Booking.PaymentStatus.AWAITING_PAYMENT || booking.getPaymentStatus() == Booking.PaymentStatus.PAID) {            booking.setPaymentStatus(Booking.PaymentStatus.REFUNDED);            log.info("El estado del pago para la reserva ID: {} ha sido actualizado a REEMBOLSADO debido a la cancelación.", bookingId);        }        booking_serviceRepository.save(booking);        log.info("Reserva cancelada con éxito. ID: {}", bookingId);    }    @Override    public List<BookingDTO> getBookingsByUserId(Long userId) {        // Utiliza el método del repositorio para obtener las entidades Booking        List<Booking> bookings = booking_serviceRepository.findByUserId(userId);        // Utiliza el mapper para convertir la lista de entidades a una lista de DTOs        return bookingMapper.toDtoList(bookings);    }    @Override    public Mono<Double> calculateTotalPriceForUser(Long userId) {        return webClient.get()                .uri(apiGatewayBaseUrl + "/ticket_services/tickets/user/{userId}", userId)                .retrieve()                .bodyToFlux(TicketDTO.class)                .filter(TicketDTO::getIsActive)  // Solo tickets activos                .map(TicketDTO::getPrice)        // Extrae el precio de cada ticket activo                .reduce(0.0, Double::sum);       // Suma los precios    }    // Este método es bloqueante y debería ser ejecutado en un contexto que permita operaciones bloqueantes.    @Transactional    public void updateBookingTotalPrice(Long userId, Double totalPrice) {        List<Booking> bookings = booking_serviceRepository.findByUserId(userId);        if (bookings.isEmpty()) {            throw new RuntimeException("No bookings found for user ID: " + userId);        }        bookings.forEach(booking -> {            booking.setTotalPrice(totalPrice);            booking_serviceRepository.save(booking);        });    }    // Este método integra ambos enfoques: reactivos para obtener datos y bloqueantes para actualizar la base de datos.    public Mono<Void> calculateAndUpdateBooking(Long userId) {        return calculateTotalPriceForUser(userId)                .publishOn(Schedulers.boundedElastic()) // Asegura que las operaciones bloqueantes no afecten el hilo principal.                .doOnNext(totalPrice -> {                    updateBookingTotalPrice(userId, totalPrice);                })                .then();    }}